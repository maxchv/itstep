
VIEWS (представления)
=====================

----

VIEWS
=====

**Представления** - это виртульная таблица чье содержание выбирается или получается из других таблиц.

Представления испоьзуются в запросах и операторах **DML** точно также как и основные таблицы, но не содержат никаких собственных данных.

**Представление** - это фактически SQL запрос, который выполняется всякий раз, когда происходит обращение к представлению.

В представление можно добавлять функции SQL, команды WHERE, JOIN и представлять данные из различных таблиц так как будто они находятся в одной таблице.

.. image:: http://www.dotnetinterviewquestions.in/contentpics/view....png

----

Преимущества представлений:
===========================

..
    1. Дает возможность *гибкой настройки прав доступа к данным* за счет того, что
   права даются не на таблицу, а на представление.
   Это очень удобно в случае если пользователю нужно дать права на отдельные
   строки таблицы или возможность получения не самих данных, а результата каких-то действий над ними.
    2. Позволяет разделить логику хранения данных и программного обеспечения.
   Можно менять структуру данных, не затрагивая программный код, нужно лишь
   создать представления, аналогичные таблицам, к которым раньше обращались приложения.
   Это очень удобно когда нет возможности изменить программный код или к
   одной базе данных обращаются несколько приложений с различными требованиями к
   структуре данных.
    3. Удобство в использовании за счет автоматического выполнения таких действий
   как доступ к определенной части строк и/или столбцов, получение данных
   из нескольких таблиц и их преобразование с помощью различных функций.

1.  **Безопасность**. Каждому пользователю можно разрешить доступ к небольшому 
    числу представлений, содержащих только ту информацию,
    которую ему позволено знать. Таким образом можно осуществить ограничение 
    доступа пользователей к хранимой информации.

2.  **Простота запросов**. С помощью представления можно извлечь данные
    из нескольких таблиц и представить их как одну таблицу, превращая тем
    самым запрос ко многим таблицам в однотабличный запрос к представлению.

3.  **Структурная простота**. С помощью представлений для каждого поль
    зователя можно создать собственную структуру базы данных, определив
    ее как множество доступных пользователю виртуальных таблиц.

4.  **Защита от изменений**. Представление может возвращать непротиворечивый и 
    неизменный образ структуры базы данных, даже если исходные
    таблицы разделяются, реструктуризуются или переименовываются. Заметим, однако, 
    что определение представления должно быть обновлено,
    когда переименовываются лежащие в его основе таблицы или столбцы.

5.  **Целостность данных**. Если доступ к данным или ввод данных осуществляется с помощью 
    представления, СУБД может автоматически проверять, выполняются ли 
    определенные условия целостности.

----

CREATE VIEW
===========

Создание представления
----------------------

.. sourcecode:: sql

    CREATE VIEW <имя_представления>[(<поле1>, <поле2ы>,...)] AS
        SELECT <имя_поля1>, <имя_поля2>, ...
        FROM <имя_таблицы1>, <имя_таблицы2>, ...
        WHERE <условие>;

Пример
------

Таблица Products
----------------

.. sourcecode:: sql

    SELECT ProductID, ProductName, Discontinued
        FROM Products
        LIMIT 10;

+-----------+---------------------------------+--------------+
| ProductID | ProductName                     | Discontinued |
+===========+=================================+==============+
|         1 | Chai                            | 0            |
+-----------+---------------------------------+--------------+
|         2 | Chang                           | 0            |
+-----------+---------------------------------+--------------+
|         3 | Aniseed Syrup                   | 0            |
+-----------+---------------------------------+--------------+
|         4 | Chef Anton's Cajun Seasoning    | 0            |
+-----------+---------------------------------+--------------+
|         5 | Chef Anton's Gumbo Mix          | 1            |
+-----------+---------------------------------+--------------+
|         6 | Grandma's Boysenberry Spread    | 0            |
+-----------+---------------------------------+--------------+
|         7 | Uncle Bob's Organic Dried Pears | 0            |
+-----------+---------------------------------+--------------+
|         8 | Northwoods Cranberry Sauce      | 0            |
+-----------+---------------------------------+--------------+
|         9 | Mishi Kobe Niku                 | 1            |
+-----------+---------------------------------+--------------+
|        10 | Ikura                           | 0            |
+-----------+---------------------------------+--------------+

----

Пример
======

Создать представление "Current Product List" для всех продуктов
(которые есть в наличии) из таблицы "Products".


Создаем выборку
---------------

.. sourcecode:: sql

    SELECT ProductID, ProductName
    	FROM Products
        WHERE  Discontinued="No";

Создаем представление
---------------------

.. Теперь можем создать представление на базе этого запроса:

.. sourcecode:: sql

    -- создание представления
    CREATE VIEW `Current Product List` AS
        SELECT ProductID, ProductName FROM Products
        WHERE  Discontinued="No";

    -- выборка из представления
    SELECT * FROM `Current Product List` LIMIT 5;

+-----------+------------------------------+
| ProductID | ProductName                  |
+===========+==============================+
|         1 | Chai                         |
+-----------+------------------------------+
|         2 | Chang                        |
+-----------+------------------------------+
|         3 | Aniseed Syrup                |
+-----------+------------------------------+
|         4 | Chef Anton's Cajun Seasoning |
+-----------+------------------------------+
|         6 | Grandma's Boysenberry Spread |
+-----------+------------------------------+

----

Типы представлений
==================

Условно, представления можно разделить на следующие типы:


1. `Горизонтальные представления`_

2. `Вертикальные представления`_

3. `Смешанные представления`_

4. `Сгруппированные представления`_

5. `Соединенные представления`_

----

Горизонтальные представления
============================

Представления широко применяются для ограничения доступа пользователей
к строкам таблиц, чтобы пользователи могли видеть не все строки, а только некото
рые из них.

Например, можно позволить менеджеру по продажам 
видеть в таблице **SALESREPS** только строки служащих, работающих в его регионе. 

Для этого можно использовать два приведенных далее представления.

Представление, показывающее информацию о служащих восточного региона.

.. sourcecode:: sql

    CREATE VIEW EASTREPS AS
        SELECT *
        FROM SALESREPS
        WHERE REP_OFFICE IN (11, 12, 13);

Представление, показывающее информацию о служащих западного региона.

.. sourcecode:: sql

    CREATE VIEW WESTREPS AS
        SELECT *
        FROM SALESREPS
        WHERE REP_OFFICE IN (21, 22);

Теперь каждому менеджеру по продажам можно разрешить доступ либо
к представлению **EASTREPS**, либо к **WESTREPS** и одновременно запретить доступ
к другому представлению, а также к таблице **SALESREPS**.

----


Вертикальные представления
==========================

Еще одним распространенным применением представлений является ограничение доступа к столбцам таблицы.

Например, отделу, обрабатывающему заказы, для выполнения своих функций может потребоваться 
следующая информация: имя, идентификатор служащего и офис, в котором он работает. 

Но отделу вовсе не обязательно знать плановый и фактический объемы продаж того или иного служащего. 
Такой избирательный образ таблицы **SALESREPS** можно получить с помощью приведенного ниже представления.

.. sourcecode:: sql

    CREATE VIEW REPINFO AS
        SELECT EMPL_NUM, NAME, REP_OFFICE
        FROM SALESREPS;

Разрешив отделу обработки заказов доступ к этому представлению и одновременно 
запретив доступ к самой таблице **SALESREPS**, можно ограничить доступ
к конфиденциальной информации, каковой являются фактический и плановый
объемы продаж.

----

Смешанные представления
=======================

При создании представлений SQL не разделяет их на горизонтальные и вертикальные. 

В SQL просто отсутствуют понятия горизонтального и вертикального
представлений. 

Они лишь помогают вам понять, каким образом из исходной таблицы 
формируется представление. 

Использование представлений, разделяющих
исходную таблицу как в горизонтальном, так и вертикальном направлении, —
вполне распространенное явление.

----

Сгруппированные представления
=============================

Запрос, определяющий представление, может содержать предложение **GROUP BY**.

Представление такого типа называется сгруппированным представлением, поскольку
данные в нем являются результатом запроса с группировкой. 

Сгруппированные представления 
выполняют ту же функцию, что и запросы с группировкой, — в них родственные строки 
данных объединяются в группы и для каждой группы в таблице результатов запроса 
создается одна строка, содержащая итоговые данные по этой группе. 

С помощью сгруппированного представления запрос с группировкой превращается в 
виртуальную таблицу, к которой в дальнейшем можно обращаться с запросами.

----

Соединенные представления
=========================

Часто представления используют для упрощения многотабличных запросов.

Задавая в определении представления двух- или трехтабличный запрос, можно
создать соединенное представление — виртуальную таблицу, данные в которую 
извлекаются из двух или трех различных таблиц. 

После создания такого представления к нему можно обращаться с помощью 
однотабличного запроса; в противном случае пришлось бы применять двух- 
или трехтабличное соединение. 

----

Изменение представления
=======================

.. You can update a view by using the following syntax:

Если представление ноебходимо изменить, то можно воспользоватся следующей командой

.. sourcecode:: sql

    CREATE OR REPLACE VIEW <имя_представления> AS
        SELECT <имя_поля1>, <имя_поля2>, ...
        FROM <имя_таблицы1>, <имя_таблицы2>, ...
        WHERE <условие>;


Пример
------

Теперь добавим поле Category к представлению "Current Product List".

.. sourcecode:: sql

    -- обновляем представление
    CREATE OR REPLACE VIEW `Current Product List` AS
        SELECT ProductID, ProductName, CategoryName FROM Products, Categories
        WHERE  Discontinued="No" AND Products.CategoryID=Categories.CategoryID;

    -- выборка из представления
    SELECT * FROM `Current Product List` LIMIT 5;

+-----------+----------------+--------------+
| ProductID | ProductName    | CategoryName |
+===========+================+==============+
|         1 | Chai           | Beverages    |
+-----------+----------------+--------------+
|         2 | Chang          | Beverages    |
+-----------+----------------+--------------+
|        34 | Sasquatch Ale  | Beverages    |
+-----------+----------------+--------------+
|        35 | Steeleye Stout | Beverages    |
+-----------+----------------+--------------+
|        38 | Cte de Blaye   | Beverages    |
+-----------+----------------+--------------+

----

Удаление представлений
======================

Синтаксис удаления представления из базы данных подобен синтаксису удаления базовых таблиц:

.. sourcecode:: sql

    DROP VIEW [IF EXISTS] <имя_представления>;

Пример
------

Удалить представление "Current Product List"

.. sourcecode:: sql

    DROP VIEW `Current Product List`;

----

Задание
=======

1. Создайте представление которое бы показывало заказчиков
   которые имеют наивысший рейтинг (rating). Таблица **Customers**.

.. role::   sql(code)
.. highlight:: guess

.notes: :sql:`CREATE VIEW Highratings AS SELECT * FROM Customers WHERE rating=(SELECT MAX(rating) FROM Customers);`

.. select * from Highratings;

Результат
---------
+------+----------+---------+--------+------+
| cnum | cname    | city    | rating | snum |
+======+==========+=========+========+======+
| 2004 | Grass    | Berlin  |    300 | 1002 |
+------+----------+---------+--------+------+
| 2008 | Cisneros | SanJose |    300 | 1007 |
+------+----------+---------+--------+------+

..
    Таблица Customers
    -----------------

    +------+----------+---------+--------+------+
    | cnum | cname    | city    | rating | snum |
    +======+==========+=========+========+======+
    | 2001 | Hoffman  | London  |    100 | 1001 |
    +------+----------+---------+--------+------+
    | 2002 | Giovanni | Rome    |    200 | 1003 |
    +------+----------+---------+--------+------+
    | 2003 | Liu      | SanJose |    200 | 1002 |
    +------+----------+---------+--------+------+
    | 2004 | Grass    | Berlin  |    300 | 1002 |
    +------+----------+---------+--------+------+
    | 2006 | Clemens  | London  |    100 | 1001 |
    +------+----------+---------+--------+------+
    | 2007 | Pereira  | Rome    |    100 | 1004 |
    +------+----------+---------+--------+------+
    | 2008 | Cisneros | SanJose |    300 | 1007 |
    +------+----------+---------+--------+------+

2. Создайте представление которое бы показывало количество продавцов в каждом
   городе (city). Таблица **Salespeople**.

.notes:  :sql:`CREATE OR REPLACE VIEW Citynumber AS SELECT city, COUNT(DISTINCT snum) AS count FROM Salespeople GROUP BY city;`

Результат:
----------

.. SELECT * FROM Citynumber;

+-----------+-------+
| city      | count |
+===========+=======+
| Barcelona |     1 |
+-----------+-------+
| London    |     2 |
+-----------+-------+
| New York  |     1 |
+-----------+-------+
| San Jose  |     1 |
+-----------+-------+

..
    Таблица Salespeople
    -------------------

    +------+---------+-----------+------+
    | snum | sname   | city      | comm |
    +======+=========+===========+======+
    | 1001 | Peel    | London    | 0.12 |
    +------+---------+-----------+------+
    | 1002 | Serres  | San Jose  | 0.13 |
    +------+---------+-----------+------+
    | 1003 | Axelrod | New York  | 0.10 |
    +------+---------+-----------+------+
    | 1004 | Motika  | London    | 0.11 |
    +------+---------+-----------+------+
    | 1007 | Rifkin  | Barcelona | 0.15 |
    +------+---------+-----------+------+


----

Обновление представлений
========================

В исходном стандарте `SQL1` четко указано, какие представления базы данных
обновимы в соответствии со стандартом (обновимость в данном контексте означает
вставку, модификацию или удаление). 

Согласно стандарту, представление можно
обновлять в том случае, если определяющий его запрос соответствует всем пере=
численным ниже ограничениям.

1.  Должен отсутствовать предикат **DISTINCT**, т.е. повторяющиеся строки не
    должны исключаться из таблицы результатов запроса.

2.  В предложении **FROM** должна быть задана только одна обновляемая таблица, 
    т.е. у представления должна быть одна исходная таблица, а пользователь 
    должен иметь соответствующие права доступа к ней. Если исходная таблица 
    сама является представлением, то оно также должно удовлетворять этим условиям.

3.  Каждое имя в списке возвращаемых столбцов должно быть ссылкой на
    простой столбец; в этом списке не должны содержаться выражения, вычисляемые 
    столбцы или статистические функции.

4.  Предложение **WHERE** не должно содержать подчиненный запрос; в нем
    могут присутствовать только простые построчные условия отбора.

5.  В запросе не должны содержаться предложения **GROUP BY** и **HAVING**.


   Чтобы представление было обновимо, СУБД должна быть способна для каждой 
   строки представления найти соответствующую строку
   в исходной таблице, а для каждого обновляемого столбца представления — 
   соответствующий столбец в исходной таблице.

----

Обновление представлений
========================

Представление может теперь изменяться командами модификации DML.

Синтаксис обновления
--------------------

.. sourcecode:: sql

         UPDATE <имя_представления>
            SET <имя_поля> = <значение>
            WHERE <условие>;

Но модификация не будет воздействовать на само представление. Команды будут на самом деле
перенаправлены к базовой таблице.


Пример:
-------

.. sourcecode:: sql

    UPDATE `Current Product List` 
        SET ProductName='Chaii'
        WHERE ProductID=1;

Эквивалентна выплнению команды:

.. sourcecode:: sql

    UPDATE Products
        SET ProductName='Chaii'
        WHERE ProductID=1;

----

Обновление представления
========================

Однако, если в представлении остутсвуют заданные поля, то изменения будут отвергнуты.

Например, в таблице **Products** есть поле **Discontinued**, однакое в представлении 
**"Current Product List"** этого поля нет

.. sourcecode:: sql

    SELECT * FROM `Current Product List` LIMIT 5;

+-----------+----------------+--------------+
| ProductID | ProductName    | CategoryName |
+===========+================+==============+
|         1 | Chai           | Beverages    |
+-----------+----------------+--------------+
|         2 | Chang          | Beverages    |
+-----------+----------------+--------------+
|        34 | Sasquatch Ale  | Beverages    |
+-----------+----------------+--------------+
|        35 | Steeleye Stout | Beverages    |
+-----------+----------------+--------------+
|        38 | Cte de Blaye   | Beverages    |
+-----------+----------------+--------------+


, поэтому команда

.. sourcecode:: sql


    UPDATE `Current Product List`
        SET Discontinued=0
        WHERE ProductID=1;

не будет выполнена.

----

CHECK OPTION
============

Если представление создается посредством запроса с предложением WHERE, то в
представлении будут видны только строки, удовлетворяющие условию отбора.
Остальные строки могут присутствовать в исходной таблице, но быть невидимы в
представлении

Рассмотрим такое представление:
 
.. sourcecode:: sql

          CREATE VIEW Highratings 
             AS SELECT cnum, rating 
                FROM Customers 
                WHERE rating = 300;

Это - представление модифицируемое. Оно просто ограничивает доступ к определенным 
строкам и столбцам в таблице. 

Предположим, что мы вставляем следующую строку:
 
.. sourcecode:: sql

       INSERT INTO Highratings 
          VALUES (2018, 200); 

Это - допустима команда в этом представлении. 
Строка будет вставлена, в таблицу Customers, однако когда она появится там, 
она исчезнет из представления, поскольку значение оценки не равно 300.  
Для решения проблемы можно использовать **WITH CHECK OPTION** в определении представления.
 
.. sourcecode:: sql

          CREATE VIEW Highratings 
             AS SELECT cnum, rating 
                FROM Customers 
                WHERE rating = 300 
                WITH CHECK OPTION; 
----

Задание
=======

.. Создайте представление которое бы показывало каждого продавца с многочисленными заказчиками.

1. Создайте представление таблицы Customers, которое должно включать только поле comm и snum. 
   С помощью этого представления, можно будет вводить или изменять комиссионные, 
   но только для значений между 0.10 и 0.20.

.notes: :sql:`CREATE VIEW Commissions AS SELECT snum, comm FROM Salespeople WHERE comm BETWEEN .10 AND .20 WITH CHECK OPTION;` 

Результат
---------

+------+------+
| snum | comm |
+======+======+
| 1001 | 0.12 |
+------+------+
| 1002 | 0.13 |
+------+------+
| 1003 | 0.10 |
+------+------+
| 1004 | 0.11 |
+------+------+
| 1007 | 0.15 |
+------+------+

2. Добавте новые записи

.. sourcecode:: sql

   INSERT INTO Commissions(snum, comm) VALUES(1008, 0.16);
   INSERT INTO Commissions(snum, comm) VALUES(1009, 0.20);
   INSERT INTO Commissions(snum, comm) VALUES(1010, 0.10);
   INSERT INTO Commissions(snum, comm) VALUES(1011, 0.09);
   INSERT INTO Commissions(snum, comm) VALUES(1012, 0.21);




----

Недостатки представлений
========================

1.  **Производительность**. Представление создает лишь видимость существования 
    соответствующей таблицы, и СУБД приходится преобразовывать запрос к 
    представлению в запрос к исходным таблицам. Если представление
    отображает многотабличный запрос, то простой запрос к представлению
    становится сложным объединением и на его выполнение может потребоваться 
    много времени. 
    Однако это связано не с тем, что запрос обращается
    к представлению, — любой плохо построенный вопрос может вызвать проблемы 
    с производительностью. Дело в том, что сложность запроса скрывается 
    в представлении, так что пользователи не представляют, какой объем
    работы может вызвать даже кажущийся простым запрос.

2.  **Управляемость**. Представления, как и все прочие объекты баз данных,
    должны быть управляемы. Если разработчики и пользователи баз данных
    смогут бесконтрольно создавать представления, то работа администратора
    базы данных станет существенно сложнее. Это в особенности справедливо
    в том случае, когда создаются представления, в основе которых лежат другие 
    представления, которые, в свою очередь, могут быть основаны на других 
    представлениях. Чем больше уровней между базовыми таблицами и
    представлениями, тем сложнее решать проблемы с представлениями, которые 
    могут возникнуть в такой системе.

3.  **Ограничения на обновление**. Когда пользователь пытается обновить
    строки представления, СУБД должна преобразовать запрос в запрос на
    обновление строк исходных таблиц. Это возможно для простых представлений; 
    более сложные представления обновлять нельзя, они доступны только для выборки.

----


Полезные ссылки
===============

- `Понимание представлений`_
- `SQL Views`_
- `CREATE VIEW (Transact-SQL)`_
- `Представления (VIEW) в MySQL`_
- `CREATE VIEW Oracle`_

.. _Понимание представлений: http://www.sql.ru/docs/sql/u_sql/ch20.shtml

.. _SQL Views: http://www.w3schools.com/sql/sql_view.asp

.. _CREATE VIEW (Transact-SQL): https://msdn.microsoft.com/ru-ru/library/ms187956(v=sql.120).aspx

.. _Представления (VIEW) в MySQL: http://habrahabr.ru/post/47031/

.. _CREATE VIEW Oracle: http://sql-language.ru/create-view.html



