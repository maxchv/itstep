
Процедуры, функции, триггеры
============================

----

Хранимые процедуры
==================

**Хранимые процедуры (stored procedure)** -  это именованный набор команд, хранящийся
непосредственно на сервере и представляющий собой самостоятельный объект базы данных. 

Без хранимых процедур пользователю пришлось бы вводить весь набор команд всякий раз,
когда он хочет выполнить какое-либо действие.

.. image:: http://www.mysqltutorial.org/wp-content/uploads/2009/12/mysql-stored-procedure1.jpg

----

Преимущества хранимых процедур:
==============================

- Использование хранимых процедур повышает скорость выполнения операций, так
  как процедура предварительно компилируется на сервере, и при повторном вызове
  процедура уже загружена в память (кэш), где найти ее можно гораздо быстрее, 
  чем на диске, к тому же не нужна повторная компиляция и оптимизация.

- Хранимые процедуры могут состоять из десятков и сотен команд, но для их
  запуска достаточно указать всего лишь имя нужной хранимой процедуры. Это позволяет уменьшить размер запроса, посылаемого по сети от клиента на сервер, так как весь набор команд находится в том месте, где он должен быть выполнен. Таким образом, при использовании хранимых процедур возможно уменьшение нагрузки на сеть.
  
- Использование хранимых процедур реализует принцип модульного проектирования,
  так как процедуры позволяют разбивать большие задачи на самостоятельные, более
  мелкие и удобные в управлении части.


----

Создание подпрограмм
====================

Сохраненная подпрограмма является процедурой или функцией. 

Сохраненные подпрограммы создаются командами **CREATE PROCEDURE** и **CREATE FUNCTION**. 

Процедура вызывается через инструкцию **CALL (EXEC)**, и может `только передавать обратные значения,
используя переменные вывода.` 

Функция может быть вызвана точно так же, как и любая другая функция языка (то есть, вызывая имя функции),
и `может возвращать скалярное значение`. 

Сохраненные подпрограммы, разумеется, могут вызывать другие сохраненные подпрограммы.

.. sourcecode:: sql

    -- Синтаксис создания процедуры
    CREATE PROCEDURE имя_процедуры ([параметр_процедуры[,...]])
            [характеристика ...] тело_подпрограммы

    -- синтаксис создания функции
    CREATE FUNCTION имя_функции ([параметр_функции[,...]])
            RETURNS тип
            [характеристика ...] тело_подпрограммы

параметр_процедуры: [ **IN** | **OUT** | **INOUT** ] имя_параметра тип

параметр_функции: имя_параметра тип

тип: Любой тип данных SQL

тело_подпрограммы: Правильное  SQL выражение.

----

Пример создания процедуры
=========================

Синтаксис
---------

.. sourcecode:: sql

    DELIMITER // -- задание разделителя команд

    CREATE PROCEDURE procedure1                     /* имя              */
        (IN parameter1 INTEGER)                     /* входной параметр */
        BEGIN                                       /* начало блока     */
            DECLARE variable1 CHAR(10);             /* переменные       */
            IF parameter1 = 17 THEN                 /* начало IF        */
                SET variable1 = 'birds';            /* присвоение       */
            ELSE
                SET variable1 = 'beasts';           /* присвоение       */
            END IF;                                 /* конец IF         */
            INSERT INTO table1 VALUES (variable1);  /* запрос           */
        END //                                      /* конец блока      */
    
    DELIMITER ;

Вызов процедуры
---------------

.. sourcecode:: sql
    
    CALL procedure1(10);

----

Переменные
==========

Локальные переменные
---------------------

Команда DECLARE
~~~~~~~~~~~~~~~

.. sourcecode:: sql

    DECLARE <имя_переменной>[,...] <тип_переменной>
        [DEFAULT <значение_по_умолчанию>]

Пример:
~~~~~~~

.. sourcecode:: sql

    DECLARE iVar INT DEFAULT 0;
    SET iVar = 5;
    SELECT * FROM `data` WHERE `id` = iVar;
 
    DECLARE iVar INT DEFAULT 0;
    SELECT COUNT(*) INTO iVar FROM `data`;

Системные переменные
--------------------

Команда SET
~~~~~~~~~~~

.. sourcecode:: sql

    SET <имя_переменной> = <значение>
        [, <имя_переменной> = <значение>] ...

Пример:
~~~~~~~

.. sourcecode:: sql

    SET @iVar = 5;
    SELECT @iVar;

----

Параметры
=========

.. Хранимые процедуры могут иметь **IN**, **OUT** и **INOUT** параметры.

IN 
--

По умолчанию. Этот параметр принимается процедурой и может изменяться внутри процедуру, но не может изменятся вне процедуры.

.. sourcecode:: sql

    CREATE PROCEDURE sp_in(p VARCHAR(11)) SET @x = P;  
    CALL sp_in('Hello world');  
    SELECT @x


OUT
---

Значения не передаются, но могут быть изменены внутри процедуры, а также изменены вне процедуры.

.. sourcecode:: sql

    SET @x='Something';  
    CREATE PROCEDURE sp_out(OUT p VARCHAR(10)) SET P='Hello world';  
    CALL sp_out(@x);  
    SELECT @x

INOUT
-----

Совмещает в себе свойства параметров IN и OUT. Значение может передаваться в процедуру, изменяться внутри процедуры и быть доступным вне процедуры.

.. sourcecode:: sql

    CREATE PROCEDURE sp_inout(INOUT P INT) SET @x=P*2;  
    set @a = 5;  
    CALL sp_inout(@a);  
    SELECT @x  

----

DELIMITER
=========

Хранимые процедуры, конечно, не очень полезные если они содержат одну инструкцию. 

Как же отличить инструкцию внутри процедуры от конца этой процедуры. 

Для этого можно создать другой разделитель инструкции для конца оператора **CREATE PROCEDURE**.

Синтаксис
---------


.. sourcecode:: sql
    
    DELIMITER <строка/символ>


Пример
------

.. sourcecode:: sql
    
    SELECT VERSION();

    -- установить разделитель команд |
    DELIMITER |

    SELECT VERSION()|

Обратите внимание на то, что нет точки с запятой после символа «|», который будет использоваться в процедуре. 

Разделитель необходимо выбарать такой, который не будет использоваться в процедуре, и он может содержать больше чем 
один символ.

----

Команда SELECT ... INTO
=======================

Позволяет сохранить выбранные столбцы непосредственно в переменные

Синтаксис
---------

.. sourcecode:: sql

    SELECT <имя_поля1>[,<имя_поля2>,...]
       INTO <имя_переменной1,>[,<имя_переменной2>,...] <запрос>

Пример
------

.. sourcecode:: sql

    -- устанавливаем разделитель
    DELIMITER $$

    -- создаем процедуру
    CREATE PROCEDURE get_title(IN _id INT, OUT _title VARCHAR(255))
    BEGIN
        SELECT title INTO _title 
            FROM t1 WHERE id=_id;
    END$$

    -- восстанавливаем стандартный разделитель 
    DELIMITER ;

    SET @title = '';
    CALL get_title(1, @title);
    SELECT @title;


----

Условие IF
==========

Синтаксис
---------

.. sourcecode:: sql

    IF <условие> THEN
        <действие>;
    END IF;

.. image:: http://www.mysqltutorial.org/wp-content/uploads/2013/01/mysql-if-statement1.jpg

----

Условие IF .. ELSE
==================

Синтаксис
---------

.. sourcecode:: sql

    IF <условие> THEN
        <действие 1>;
    ELSE
        <действие 2>;
    END IF;

.. image:: http://www.mysqltutorial.org/wp-content/uploads/2013/01/mysql-if-else-statement.jpg

----

Условие IF .. ELSEIF .. ELSE
============================

Синтаксис
---------

.. sourcecode:: sql

    IF <условие 1> THEN
        <действие 1>;
    ELSEIF <условие 2> THEN
        <действие 2>;
    ...
    ELSE
        <действие n>;
    END IF;

.. image:: http://www.mysqltutorial.org/wp-content/uploads/2013/01/mysql-if-elseif-else-statement.jpg
    :width: 240px

----

Пример применения условий
=========================

.. sourcecode:: sql

    DELIMITER $$     
    CREATE PROCEDURE GetCustomerLevel
    (
        IN  p_customerNumber INT(11), 
        OUT p_customerLevel  VARCHAR(10)
    )
    BEGIN
        DECLARE creditlim DOUBLE;
     
        SELECT creditlimit INTO creditlim
            FROM customers
            WHERE customerNumber = p_customerNumber;
     
        IF creditlim > 50000 THEN
            SET p_customerLevel = 'PLATINUM';
        ELSEIF (creditlim <= 50000 AND creditlim >= 10000) THEN
            SET p_customerLevel = 'GOLD';
        ELSEIF creditlim < 10000 THEN
            SET p_customerLevel = 'SILVER';
        END IF;
    END$$

----

.. image:: http://www.mysqltutorial.org/wp-content/uploads/2013/01/mysql-if-statement-flow-chart.png

----

CASE
====

.. Besides the IF statement, MySQL provides an alternative conditional statement called CASE. 
.. The MySQL CASE statement makes the code more readable and efficient.

Вместе с условными командами в MySQL применяются условные выражения **CASE**.

**CASE** выражения позволяют создать код более читабельным и эффективным. 

.. There are two forms of the CASE statements: simple and searched CASE statements.

Существует две формы CASE выражений: простое и поисковое.

Простое CASE выражение
----------------------

В этом случае находится совпадение выражения с одним из уникальных значений и 
выполнение соответствующих команд

.. sourcecode:: sql

    CASE  <выражение>
       WHEN <знечение 1> THEN <команды 1>
       WHEN <значение 2> THEN <команды 2>
       ...
       ELSE <команды n>
    END CASE;


----

Пример CASE
===========

.. sourcecode:: sql

    DELIMITER $$     
    CREATE PROCEDURE GetCustomerShipping
    (
         IN  p_customerNumber INT(11), 
         OUT p_shiping        VARCHAR(50)
    )
    BEGIN
        DECLARE customerCountry VARCHAR(50);
     
        SELECT country INTO customerCountry
             FROM customers
             WHERE customerNumber = p_customerNumber;
     
        CASE customerCountry
             WHEN  'USA' THEN
                SET p_shiping = '2-day Shipping';
             WHEN 'Canada' THEN
                SET p_shiping = '3-day Shipping';
             ELSE
                SET p_shiping = '5-day Shipping';
         END CASE;     
    END$$

----

Пример CASE
===========


.. image:: http://www.mysqltutorial.org/wp-content/uploads/2013/01/mysql-case-statement.png

----

Поисковый CASE
==============

.. The simple CASE statement only allows you match a value of an expression against a set of distinct values. In order to perform more complex matches such as ranges, you use the searched CASE statement. The searched CASE statement is equivalent to the IF  statement, however, its construct is much more readable.

Простые **CASE** выражения позволяют находить только совпадения с уникальными значениями для некого выражения.

Для применения больее сложных условий используется поисковый варианты выражения **CASE**.

Он похож на условие **IF**, но имеет более читабельный вид.

Синтаксис
---------

.. sourcecode:: sql

    CASE
        WHEN <условие_1> THEN <команды_1>
        WHEN <условие_2> THEN <команды_2>
        ...
        ELSE <команды_n>
    END CASE;

----

Пример применения CASE
======================

.. sourcecode:: sql

    DELIMITER $$
    CREATE PROCEDURE GetCustomerLevel
    (
     IN  p_customerNumber INT(11), 
     OUT p_customerLevel  VARCHAR(10)
    )
    BEGIN
        DECLARE creditlim DOUBLE;
        SELECT creditlimit INTO creditlim
            FROM customers
            WHERE customerNumber = p_customerNumber;
        CASE  
            WHEN creditlim > 50000 THEN 
                SET p_customerLevel = 'PLATINUM';
            WHEN (creditlim <= 50000 AND creditlim >= 10000) THEN
                SET p_customerLevel = 'GOLD';
            WHEN creditlim < 10000 THEN
                SET p_customerLevel = 'SILVER';
        END CASE;
    END$$
    
    CALL GetCustomerLevel(112,@level);
    SELECT @level AS 'Customer Level';


+----------------+
| Customer Level |
+================+
| PLATINUM       |
+----------------+

----

Цикл WHILE
==========

Запрос будет выполняться до тех пор, пока условие истинно.

.. sourcecode:: sql

    WHILE условие DO
        действие;
    END WHILE;

.. image:: http://www.mysqltutorial.org/wp-content/uploads/2009/12/mysql-while-loop.jpg

----

Пример цикла WHILE
==================

.. sourcecode:: sql

    DELIMITER $$

    CREATE PROCEDURE test_mysql_while_loop()
    BEGIN
        DECLARE x  INT;
        DECLARE str  VARCHAR(255);

        SET x = 1;
        SET str =  '';

        WHILE x  <= 5 DO
            SET  str = CONCAT(str,x,',');
            SET  x = x + 1; 
        END WHILE;

        SELECT str;
    END$$
    
    DELIMITER ;

    CALL test_mysql_while_loop();


+------------+
| str        |
+============+
| 1,2,3,4,5, |
+------------+

----

Цикл REPEAT
===========

Условие цикла проверяется не в начале, как в цикле **WHILE**, а в конце, т.е. хотя бы один раз, но цикл выполняется. 

Сам же цикл выполняется, пока условие ложно. 


Синтаксис
---------

.. sourcecode:: sql

    REPEAT <запрос>
    UNTIL <условие> 
    END REPEAT

.. image:: http://www.mysqltutorial.org/wp-content/uploads/2009/12/mysql-repeat-loop.jpg

----

Пример цикла REPEAT
===================

.. sourcecode:: sql

    DELIMITER $$
    CREATE PROCEDURE mysql_test_repeat_loop()
    BEGIN
        DECLARE x INT;
        DECLARE str VARCHAR(255);
        
        SET x = 1;
        SET str =  '';
        
        REPEAT
            SET  str = CONCAT(str,x,',');
            SET  x = x + 1; 
        UNTIL x  > 5
        END REPEAT;

        SELECT str;
    END$$
    DELIMITER ;

----

Цикл LOOP 
=========

Этот цикл вообще не имеет условий (бесконечный цикл), поэтому обязательно должен иметь оператор **LEAVE** 
(аналог break) для прекращения цикла.

Также может быть использована команда **ITERATE** (аналог continue) для перехода к следующей итерации



Синтаксис
---------
    
.. sourcecode:: sql

    LOOP запрос 
    END LOOP

----

Пример цикла LOOP
=================

.. sourcecode:: sql

    DELIMITER $$
    CREATE PROCEDURE test_mysql_loop()
    BEGIN
        DECLARE x  INT;
        DECLARE str  VARCHAR(255);        

        SET x = 1;
        SET str =  '';        
        
        loop_label:  LOOP
        IF  x > 10 THEN 
            LEAVE  loop_label;
        END  IF;            
        SET  x = x + 1;
        
        IF  (x mod 2) THEN
            ITERATE  loop_label;
        ELSE
            SET  str = CONCAT(str,x,',');
        END  IF;
        END LOOP;
        SELECT str;
    END;

----

Stored Function
===============

.. http://www.mysqltutorial.org/mysql-stored-function/

A stored function is a special kind stored program that returns a single value. You use stored functions to encapsulate common formulas or business rules that are reusable among SQL statements or stored programs.

Different from a stored procedure, you can use a stored function in SQL statements wherever an expression is used. This helps improve the readability and maintainability of the procedural code.
tored function syntax

The following illustrates the simplest syntax for creating a new stored function:

.. sourcecode:: sql

    CREATE FUNCTION function_name(param1,param2,…)
        RETURNS datatype
        [NOT] DETERMINISTIC
    statements

----

stored function example
=======================

The following example is a function that returns the level of a customer based on credit limit. We use the IF statement to decide the credit limit.

.. sourcecode:: sql

    DELIMITER $$
    CREATE FUNCTION CustomerLevel(p_creditLimit double) RETURNS VARCHAR(10)
        DETERMINISTIC
    BEGIN
        DECLARE lvl varchar(10);
     
        IF p_creditLimit > 50000 THEN
            SET lvl = 'PLATINUM';
        ELSEIF (p_creditLimit <= 50000 AND p_creditLimit >= 10000) THEN
            SET lvl = 'GOLD';
        ELSEIF p_creditLimit < 10000 THEN
            SET lvl = 'SILVER';
        END IF;
     RETURN (lvl);
    END$$    

Now, we can call the CustomerLevel() in an SQL SELECT statement as follows:

.. sourcecode:: sql

    SELECT 
        customerName, CustomerLevel(creditLimit)
    FROM
        customers
    ORDER BY customerName;

----

Изменения подпрограмм
=====================

ALTER PROCEDURE | FUNCTIN
-------------------------

.. sourcecode:: sql

    ALTER {PROCEDURE | FUNCTION} sp_name
        [characteristic ...]

characteristic:

{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
   | SQL SECURITY { DEFINER | INVOKER }
   | COMMENT 'string'

ALTER FUNCTION
--------------

----

Перечень подпрограмм в MySQL
============================

Для отображения сохраненных подпрограмм в СУБД используется команда: 

Синтаксис
---------


.. sourcecode:: sql

    SHOW PROCEDURE | FUNCTION STATUS [LIKE 'pattern' | WHERE expr];

Пример
------

Для ограничения вывода применяются команды **LIKE** и **WHERE**:
Наример, для отображения процедур базы данных **northwind**:

.. sourcecode:: sql
    
    SHOW PROCEDURE STATUS WHERE db = 'northwind';

Для отображения исходного кода подпрограмм используют команды: 

Синтаксис
---------

.. sourcecode:: sql

    SHOW CREATE PROCEDURE <имя_процедуры>;

Пример
------

Отобразить исходный код процедуры CustOrderHist:

.. sourcecode:: sql

    SHOW CREATE PROCEDURE northwind.CustOrderHist;

----

Триггеры
========

**Триггер** представляет собой хранимую процедуру, которая активизируется 
при наступлении определенного события. 

Например, можно задать хранимую процедуру, которая срабатывает каждый раз 
при удалении записи из транзакционной таблицы - таким образом, 
обеспечивается автоматическое удаление соответствующего заказчика из 
таблицы заказчиков, когда все его транзакции удаляются.

Синтаксис создания триггера

.. sourcecode:: sql

    CREATE
        [DEFINER = { имя_ пользователя | CURRENT_USER }]
        TRIGGER имя_триггера время_триггера событие_срабатывания
        ON имя_таблицы FOR EACH ROW выражение
Если с именем триггера и именем пользователя все понятно сразу, то о «времени триггера» и «событии» поговорим отдельно.

время_триггера

Определяет время свершения действия триггера. BEFORE означает, что триггер выполнится до завершения события срабатывания триггера, а AFTER означает, что после. Например, при вставке записей (см. пример выше) наш триггер срабатывал до фактической вставки записи и вычислял сумму. Такой вариант уместен при предварительном вычислении каких-то дополнительных полей в таблице или параллельной вставке в другую таблицу.

событие_срабатывания_триггера

Здесь все проще. Тут четко обозначается, при каком событии выполняется триггер.

INSERT: т.е. при операциях вставки или аналогичных ей выражениях (INSERT, LOAD DATA, и REPLACE)
UPDATE: когда сущность (строка) модифицирована
DELETE: когда запись удаляется (запросы, содержащие выражения DELETE и/или REPLACE)

----

Полезные ссылки
===============

- `MySQL Stored Procedures`_
- `CREATE PROCEDURE (Transact-SQL)`_
-  `CREATE PROCEDURE Oracle Database Online Documentation`_
- `Хранимые процедуры и триггеры`_
- `Хранимые процедуры и триггеры. Активные базы данных`_ 
  
.. _MySQL Stored Procedures:  http://www.peregrinesalon.com/wp-content/uploads/2009/03/mysql-stored-procedures.pdf

.. _CREATE PROCEDURE (Transact-SQL): https://msdn.microsoft.com/ru-ru/library/ms187926(v=sql.120).aspx

.. _CREATE PROCEDURE Oracle Database Online Documentation: https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_6009.htm

.. _Хранимые процедуры и триггеры: http://www.zoonman.ru/library/mysql_sr_and_t.htm

.. _Хранимые процедуры и триггеры. Активные базы данных:  http://web.znu.edu.ua/lab/econom/dba/lectures/ADBS_lect5.pdf
